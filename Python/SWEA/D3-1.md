## 13428. 숫자조작 (아직 못품)

> **RUNTIME ERRORORORORORORORORORORORORORORORORORO**
>
> **이게 최선인데 정신 나갈거 같다.**

```python
T = int(input())
for test_case in range(1, T + 1):
    num = input()
    nums = list(num)
 
    candidates = [] # 모든 경우의 수 다 담기
 
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            nums[i], nums[j] = nums[j], nums[i]
            new = ''.join(nums)
            candidates.append(new)
            nums[j], nums[i] = nums[i], nums[j]
            
 	# 앞자리 0인수들 제거 
    candidates = list(map(int, candidates)) 
    candidates = list(filter(lambda x : len(str(x)) ==len(num), candidates))
     
    print(f'#{test_case} {min(candidates)} {max(candidates)}')
```

## 13229. 일요일

```python
T = int(input())
for tc in range(1, T+1):
    S = input()
    days= {"MON": 6,
           "TUE": 5,
           "WED": 4,
           "THU": 3,
           "FRI": 2,
           "SAT": 1,
           "SUN": 7
           }
    print(f'#{tc} {days[S]}')
```

## 13218. 조별과제

```python
T = int(input())
for tc in range(1, T+1):
    N = int(input())

    print(f'{tc} {N//3}')
```

## 13038. 교환학생 (아직 못품)

> 틀린 답

```python
T = int(input())
for tc in range(1, T+1):
    n = int(input()) # 들어야하는 수업 일수
    day = list(map(int, input().split()))

    zero = 0 # 월, 화가 0이면 수요일부터 시작이므로 결과값에서 앞에 연속된 0 빼줘야함
    for d in day:
        if d == 1:
            break
        if d == 0:
            zero += 1

    if sum(day) == 1:
        week, residue = n - 1, 1
    else:
        '''
        주어진 n에서 -1을 하지않고 divmod를 하면
        n=6 이고 1 0 0 1 0 0 0 인 경우,
        week = 3, residue = 0 이되어 18일이된다.
        근데 2주하고 4일이 정답이므로 n-1을 해주고 나중에 residue += 1  
        '''
        week, residue = divmod(n-1, sum(day)) #지내야하는 주 수, 남은 수업일 수
        residue += 1

    cnt = 0
    for d in day:
        if residue == 0:
            break
        if d == 1:
            residue -= 1
        cnt += 1


    days = week * 7 + cnt - zero


    print(f'#{tc} {days}')
```

## 12741. 두 전구

> 계속 제한시간 초과가 떴다. 두개가 왜 시간차이가 있는지 잘 모르겠다. 시간 차이가 없을 것 같은데
>
> 수정한 답

```python
T = int(input())
answers = []
for tc in range(1, T+1):
    A, B, C, D = map(int, input().split())
    answers.append(max(min(B, D) - max(A, C), 0))

for tc in range(0, T):
   print(f'#{tc+1} {answers[tc]}')
```

> 원래 답

```python
T = int(input())
for tc in range(1, T+1):
    A, B, C, D = map(int, input().split())

    '''
    2, 4 => 2초부터 3.99999초까지
    '''
    on = max(min(B,D)-max(A,C), 0)

    print(f'#{tc} {on}')
```

## 12368. 24시간

```python
T = int(input())
for tc in range(1,T+1):
    A, B = map(int, input().split())
    time = (A + B) % 24

    print(f'#{tc} {time}')
```

## 12221. 구구단2

```python
T = int(input())
for tc in range(1, T+1):
    A, B = map(int, input().split())
    if A < 10 and B < 10:
        result = A * B
    else:
        result = -1

    print(f'#{tc} {result}')
```

## 12051. 프리셀 통계

```python
T = int(input())
for tc in range(1, T+1):
    N, PD, PG = map(int, input().split())
    '''
    0. 3개의 입력 다 정수다.
    1. 오늘 한판이라도 이기면 승률이 0이 될 수 없다.
    2. 오늘 한판이라도 지면 승률이 100이 될 수 없다.
    3. N이하의 가능한 판 수 중에 PD 퍼센트를 곱해서 정수가 나와야함.
    '''
    if PD != 0 and PG == 0:
        answer = 'Broken'
    elif PD != 100 and PG == 100:
        answer = 'Broken'
    else:
        for i in range(1, N+1):
            if (i * PD) % 100 == 0:
                answer = 'Possible'
                break
        else:
            answer = 'Broken'
            
    print(f'#{tc} {answer}')

```

## 12004. 구구단1

> 처음에 N==1을 생각못해서 틀렸음

```python
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    for i in range(2, 10):
        # 2-9 중 하나로 나누어지고 나누어졌을때 10보다 작다
        if N % i == 0 and N//i < 10:
            answer = 'Yes'
            break
    else:
        answer = 'No'
        if N == 1:
            answer = 'Yes'
        
    print(f'#{tc} {answer}')
```

## 11856. 반반

```python
T = int(input())
for tc in range(1, T+1):
    S = list(input())
    cnt = {} # 알파벳과 개수를 담을 딕셔너리
    answer = 'No' #일단 No로 초기화

    for s in S:
        cnt[s] = cnt.get(s, 0) + 1

    #알파벳이 2개고, 각각 2개씩이면 Yes
    if len(cnt.keys()) == 2 and list(cnt.values()) == [2,2]:
        answer = 'Yes'

    print(f'#{tc} {answer}')
```

## 11736. 평범한 숫자

```python
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    pi = list(map(int, input().split()))

    cnt = 0 # 평범한 숫자 개수
    for i in range(1, N-1):
        # 연속된 세 숫자 중 중간이면 평범한 숫자이다
        if pi[i-1] < pi[i] < pi[i+1] or pi[i-1] > pi[i] > pi[i+1]:
            cnt += 1
            
    print(f'#{tc} {cnt}')
```

## 11688. Calkin-Wilf tree 1

```python
T = int(input())
for tc in range(1, T+1):
    LRs = list(input())
    a, b = 1, 1 # a,b root값으로 초기화

    for LR in LRs: # 제시문 내용
        if LR == 'L':
            b = a + b
        else:
            a = a + b

    print(f'#{tc} {a} {b}')
```

## 11445. 무한 사전

```python

```

## 11387. 몬스터 사냥

```python
T = int(input())
for tc in range(1, T+1):
    D, L, N = map(int, input().split())
    total = 0
    
    for i in range(N): 
        total += D * (1 + i*L/100)

    print(f'#{tc} {int(total)}')
```

## 11315. 오목 판정

> D2 파리퇴치, 스도쿠랑 비슷한 느낌

```python
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    matrix = [0] * N
    for i in range(N):
        matrix[i] = list(input())

    target = ['o'] * 5
    answer = 'NO'

    # 가로 세로 확인 (5개 이상인지 체크)
    for i in range(N):
        for j in range(N-4):
            col = [] # 열방향
            row = [] # 행방향
            for k in range(5):
                row.append(matrix[i][j+k])
                col.append(matrix[j+k][i])
            if row == target or col == target:
                answer = 'YES'
                break
    # 대각선 확인
    for i in range(N-4):
        for j in range(N-4):
            down = []  # 우하향 대각선
            up = []  # 우상향 대각선
            for k in range(5):
                down.append(matrix[i+k][j+k])
                up.append(matrix[j+k][N-1-i-k])
            if down == target or up == target:
                answer = 'YES'
                break

    print(f'#{tc} {answer}')
```

## 11285. 다트 게임

```python

```

## 10965. 제곱수 만들기

```python

```

## 10912. 외로운 문자

```python

```

## 10804. 문자열의 거울상

```python

```

## 10761. 신뢰

```python

```

