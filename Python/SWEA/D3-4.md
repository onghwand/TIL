## 3431. 준환이의 운동관리

```python
T = int(input())
for tc in range(1, T+1):
    L, U, X = map(int, input().split())
    if L <= X <= U:
        ans = 0
    elif X < L:
        ans = L - X
    else:
        ans = -1
    print(f'#{tc} {ans}')
```

## 3408. 세가지 합 구하기

```python
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    s1 = N*(N+1)//2
    s2 = N*N
    s3 = N*(N+1)

    print(f'#{tc}',s1,s2,s3)
```

## 3376. 파도반 수열

```python
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = [1,1,1,2,2]
    i = 4
    while len(arr) <= N:
        arr.append(arr[i]+arr[i-4]) #4번째 전 길이랑 합쳐져서 다음 것이 만들어짐
        i += 1

    print(f'#{tc}',arr[N-1])
```

## 3314. 보충학습과 평균

```python
T = int(input())
for tc in range(1, T+1):
    arr = list(map(int, input().split()))
    total = 0
    for score in arr:
        if score < 40:
            total += 40
        else:
            total += score
    print(f'#{tc} {total//len(arr)}') # 문제조건에 모든 점수가 5의배수라고 해서 몫으로
```

## `다시풀기`3307. 최장 증가 부분 수열

> dp를 이렇게 못떠올리는 것도 재능이다 ㅡ,,ㅡ

```python
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = list(map(int, input().split()))

    dp = [1 for i in range(N)]

    for i in range(N):
        for j in range(i):
            if arr[i] > arr[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    print(f'#{tc} {max(dp)}')
```

## 3304. 최장 공통 부분 수열

```python

```

## 3260. 두 수의 덧셈

```python
T = int(input())
for tc in range(1, T+1):
    A, B =map(int, input().split())
    print(f'#{tc} {A+B}')
```

## `다시풀기 `3282. 0/1 Knapsack

> 동적 계획법
>
> https://velog.io/@huttzza/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-0-1-Knapsack-Problem

```python
'''
0 0 0 0 0 0
0 2 2 2 2 2
0 2 2 2 4 4
0 2 2 2 4 6
0 2 3 5 5 6
행: 최대개수, 열: 최대부피

행을 하나씩 채워 나가는데
0행은 최대개수가 0개이므로 => 다 0
1행은 최대개수가 1개이므로 첫번째 물건을 검사 => 최대부피(열)를 만족하면 물건의가치(C) 추가 
2행은 최대개수가 2개이므로 최대부피가 허락한다면 => 2번째 물건을 넣어보고 + 2번째물건 부피만큼 뺐을때 1개들어있었던 배낭의 가치 vs 그냥 2번째 물건을 안넣고 그대로의 가치
반복...
'''
def knapsack(K, V, C, N): #K 무게 한도, V 각 물건 부피, C 각 물건 가치, N 물건 수
    arr = [[0 for x in range(K+1)] for x in range(N+1)]
    for i in range(N+1):
        for k in range(K+1):
            if i==0 or k==0:
                arr[i][k] = 0
            elif V[i-1] <= k:
                arr[i][k] = max(C[i-1]+arr[i-1][k-V[i-1]], arr[i-1][k])
            else:
                arr[i][k] = arr[i-1][k]

    return arr[N][K]

T = int(input())
for tc in range(1, T+1):
    N, K = map(int, input().split())
    V = [0]*N
    C = [0]*N
    for i in range(N):
        v, c = map(int, input().split())
        V[i], C[i] = v, c

    ans = knapsack(K, V, C, N)
    
    print(f'#{tc} {ans}')
```

> 시간초과..2

```python
T = int(input())
for tc in range(1, T+1):
    N, K = map(int, input().split())
    V = [0]*N
    C = [0]*N
    for i in range(N):
        v, c = map(int, input().split())
        V[i], C[i] = v, c

    maxV = 0
    for i in range(1 << N):
        v = c = 0
        for j in range(N):
            if i & (1 << j):
                v += V[j]
                c += C[j]
        if v <= K and maxV < c:
            maxV = c

    print(f'#{tc} {maxV}')
```

> 시간초과..

```python
def f(i,N,K,v,c):
    global maxV
    if v > K:
        return
    elif i == N:
        if maxV < c:
            maxV = c
        return
    else:
        f(i+1,N,K,v+V[i],c+C[i])
        f(i+1,N,K,v,c)

T = int(input())
for tc in range(1, T+1):
    N, K = map(int, input().split())
    V = [0]*N
    C = [0]*N
    for i in range(N):
        v, c = map(int, input().split())
        V[i], C[i] = v, c

    maxV = 0
    f(0, N, K, 0, 0)
    print(f'#{tc} {maxV}')
```

## 3233. 정삼각형 분할 놀이

```python
T = int(input())
for tc in range(1, T+1):
    A, B = map(int, input().split())
    n = A // B # 라인 수

    print(f'#{tc} {n*n}')
```

## 3142. 영준이와 신비한 뿔의 숲

```python
T = int(input())
for tc in range(1, T+1):
    N, M = map(int, input().split())

    for n in range(M+1): # n이 유니콘
        if n + 2 * (M - n) == N:
            ans = (n, M-n)

    print(f'#{tc}', *ans)
```

## 3131. 100만 이하의 모든 소수

```python
N = 1000000
arr = [True] * (N + 1)
for i in range(2, int(N**(1/2))+1):
    j = 2
    while i * j <= N :
        arr[i * j] = False
        j += 1
arr[0] = False
arr[1] = False

for i in range(N + 1):
    if arr[i]:
        print(i, end=' ')
```

## `다시풀기` 3032. 홍준이의 숫자 놀이 

> 확장된 유클리드 알고리즘
>
> https://www.youtube.com/watch?v=PmwLXveLtqc
>
> https://brilliant.org/wiki/extended-euclidean-algorithm/

```python
def f(a,b):
    x,y,u,v = 1,0,0,1
    while b != 0: # b가 0이 되면 끝
        q, r = a // b, a % b
        m, n = x - q*u, y - q*v
        a,b,x,y,u,v = b,r,u,v,m,n
    return x, y

T = int(input())
for tc in range(1, T+1):
    A, B = map(int, input().split())
    print(f'#{tc}', *f(A,B))
```

## 2930. 힙

```python

```

## 2948. 문자열 교집합

```python
T = int(input())
for tc in range(1, T+1):
    N, M = map(int, input().split())
    a = set(list(input().split()))
    b = set(list(input().split()))

    n = len(a.intersection(b))
    print(f'#{tc} {n}')
```

## 2817. 부분 수열의 합

> 백트래킹 ver2
>
> 실행시간: 572ms => 조건문 하나 더 추가했음, 지금까지 배운 것 중엔 최선

```python
def f(i,N,K,s,r):
    global cnt
    if s > K:
        return
    elif s + r < K: # 아직 반영하지 않은 나머지 원소들을 다 더해도 K가 될 수 없을 때 stop
        return
    elif i == N:
        if s == K:
            cnt += 1
        return
    else:
        f(i+1,N,K,s+arr[i],r-arr[i])
        f(i+1,N,K,s,r-arr[i])

T = int(input())
for tc in range(1,T+1):
    N, K = map(int, input().split())
    arr =list(map(int, input().split()))

    cnt = 0
    f(0, N, K, 0, sum(arr))
    print(f'#{tc} {cnt}')
```

> 백트래킹 ver1
>
> 실행시간: 751ms => 백트래킹이 빠른건 당연한데 차이가 좀 큰 듯

```python
def f(i,N,K,s): # i는 arr인덱스 
    global cnt
    if s > K: # 부분집합을 완성해가는 중에 합 s가 K를 넘어가면 stop
        return
    elif i == N: # 부분집합을 완성했고
        if s == K: # 합이 K면 
            cnt += 1
        return
    else:
        f(i+1,N,K,s+arr[i]) # i번째 원소를 가져가는 부분집합
        f(i+1,N,K,s) # i번재 원소를 버린 부분집합

T = int(input())
for tc in range(1,T+1):
    N, K = map(int, input().split())
    arr =list(map(int, input().split()))

    cnt = 0
    f(0,N,K,0)
    print(f'#{tc} {cnt}')
```

> Brute Force, 완전탐색
>
> 실행시간 : 4215ms 

```python
def f(N, K):
    cnt = 0
    for i in range(1<<N):
        total = 0
        for j in range(N):
            if i & (1<<j):
                total += arr[j]
        if total == K:
            cnt += 1
    return cnt

T = int(input())
for tc in range(1,T+1):
    N, K = map(int, input().split())
    arr =list(map(int, input().split()))

    ans = f(N,K)
    
    print(f'#{tc} {ans}')
```

## 2814. 최장 경로

```python

```

## 2805. 농작물 수확하기

```python
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    n = (N-1)//2
    arr = [list(map(int,input())) for _ in range(N)]
    lst = []
    for i in range(n+1):
        lst.append(i)
    for i in range(n):
        lst.append(n-i-1)

    total = 0
    for i in range(N):
        k = lst[i]
        for j in range(n-k, n+k+1):
            total += arr[i][j]
            
    print(f'#{tc} {total}')
```

## 2806. N-Queen

```python
def f(i,N):
    di = [0,0,1,-1,1,1,-1,-1]
    dj = [1,-1,0,0,1,-1,1,-1]
    global cnt
    if i == N:
        cnt += 1
    else:
        for j in range(N):
            if arr[i][j] == 0:
                # 행,열,대각선 다 i+1 로바꾸고
                arr[i][j] = i+1
                for l in range(1,N):
                    for k in range(8):
                        ni, nj =i+di[k]*l, j+dj[k]*l
                        if 0 <= ni < N and 0 <= nj < N and arr[ni][nj] == 0:
                            arr[ni][nj] = i+1
                # 다음 행으로 이동
                f(i+1, N)
                # 함수 끝내고 나오면 이전 상태로 원상복구 시켜놔야 다음 시행에 영향을 안줌
                arr[i][j] = 0
                for l in range(1, N):
                    for k in range(8):
                        ni, nj = i + di[k] * l, j + dj[k] * l
                        if 0 <= ni < N and 0 <= nj < N and arr[ni][nj] == i+1:
                            arr[ni][nj] = 0
                            
        else: # 중간에 놓을 자리가 없으면 거기서 끝
            return

T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = [[0]*N for _ in range(N)]

    cnt = 0
    f(0,N)
    print(f'#{tc} {cnt}')
```

## 1873. 상호의 배틀필드

> 인덱스 접근 종합문제느낌 ㅋㅋ..

```python
def location(H, W): # 시작 전차 위치
    for i in range(H):
        for j in range(W):
            if arr[i][j] not in '.*#-':
                return i, j

def boom(H, W, di,dj):
    k = 1
    while 0 <= i+di*k < H and 0 <= j+dj*k < W: # 맵 안에 있으면
        if arr[i+di*k][j+dj*k] == '*': # 벽돌 벽이 있으면
            arr[i+di*k][j+dj*k] = '.' # 평지로
            return
        elif arr[i+di*k][j+dj*k] == '#': # 강철 벽이면 거기서 그만
            return
        k += 1

T = int(input())
for tc in range(1, T+1):
    H, W = map(int, input().split())
    arr = [list(input()) for _ in range(H)]
    N = int(input())
    modes = list(input())

    i, j = location(H,W) # 전차 좌표
    move = {'U':[-1,0,'^'],'D':[1,0,'v'],'L':[0,-1,'<'],'R':[0,1,'>']} # 이동방향과 모양
    shoot = {'^':[-1,0],'v':[1,0],'<':[0,-1],'>':[0,1]} # 포탄 날라가는 방향

    for mode in modes:
        if mode == 'S': # 포탄 발사면
            di, dj = shoot[arr[i][j]] # 포탄 날라가는 방향 저장
            boom(H, W, di, dj) # 포탄 매뉴얼대로

        else: # 이동하는 입력이면
            di, dj, face = move[mode]
            arr[i][j] = face # 전차 방향모양 갱신
            ni, nj = i+di, j+dj
            if 0 <= ni < H and 0 <= nj < W and arr[ni][nj] == '.': # 평지면
                arr[ni][nj] = arr[i][j] # 위치 이동
                arr[i][j] = '.' # 전에 있던 자리는 평지
                i, j = ni, nj # 위치 갱신

    print(f'#{tc}', end=' ')
    for ar in arr:
        print(''.join(ar))
```

