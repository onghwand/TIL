## 3431. 준환이의 운동관리

```python
T = int(input())
for tc in range(1, T+1):
    L, U, X = map(int, input().split())
    if L <= X <= U:
        ans = 0
    elif X < L:
        ans = L - X
    else:
        ans = -1
    print(f'#{tc} {ans}')
```

## 3408. 세가지 합 구하기

```python
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    s1 = N*(N+1)//2
    s2 = N*N
    s3 = N*(N+1)

    print(f'#{tc}',s1,s2,s3)
```

## 3376. 파도반 수열

```python
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = [1,1,1,2,2]
    i = 4
    while len(arr) <= N:
        arr.append(arr[i]+arr[i-4]) #4번째 전 길이랑 합쳐져서 다음 것이 만들어짐
        i += 1

    print(f'#{tc}',arr[N-1])
```

## 3314. 보충학습과 평균

```python
T = int(input())
for tc in range(1, T+1):
    arr = list(map(int, input().split()))
    total = 0
    for score in arr:
        if score < 40:
            total += 40
        else:
            total += score
    print(f'#{tc} {total//len(arr)}') # 문제조건에 모든 점수가 5의배수라고 해서 몫으로
```

## 3307. 최장 증가 부분 수열

```python

```

## 3304. 최장 공통 부분 수열

```python

```

## 3260. 두 수의 덧셈

```python
T = int(input())
for tc in range(1, T+1):
    A, B =map(int, input().split())
    print(f'#{tc} {A+B}')
```

## 3282. 0/1 Knapsack

```python

```

## 3233. 정삼각형 분할 놀이

```python

```

## 3142. 영준이와 신비한 뿔의 숲

```python

```

## 3131. 100만 이하의 모든 소수

```python

```

## 3032. 홍준이의 숫자 놀이

```python

```

## 2930. 힙

```python

```

## 2948. 문자열 교집합

```python

```

## 2817. 부분 수열의 합

> 백트래킹 ver2
>
> 실행시간: 572ms => 조건문 하나 더 추가했음, 지금까지 배운 것 중엔 최선

```python
def f(i,N,K,s,r):
    global cnt
    if s > K:
        return
    elif s + r < K: # 아직 반영하지 않은 나머지 원소들을 다 더해도 K가 될 수 없을 때 stop
        return
    elif i == N:
        if s == K:
            cnt += 1
        return
    else:
        f(i+1,N,K,s+arr[i],r-arr[i])
        f(i+1,N,K,s,r-arr[i])

T = int(input())
for tc in range(1,T+1):
    N, K = map(int, input().split())
    arr =list(map(int, input().split()))

    cnt = 0
    f(0, N, K, 0, sum(arr))
    print(f'#{tc} {cnt}')
```

> 백트래킹 ver1
>
> 실행시간: 751ms => 백트래킹이 빠른건 당연한데 차이가 좀 큰 듯

```python
def f(i,N,K,s): # i는 arr인덱스 
    global cnt
    if s > K: # 부분집합을 완성해가는 중에 합 s가 K를 넘어가면 stop
        return
    elif i == N: # 부분집합을 완성했고
        if s == K: # 합이 K면 
            cnt += 1
        return
    else:
        f(i+1,N,K,s+arr[i]) # i번째 원소를 가져가는 부분집합
        f(i+1,N,K,s) # i번재 원소를 버린 부분집합

T = int(input())
for tc in range(1,T+1):
    N, K = map(int, input().split())
    arr =list(map(int, input().split()))

    cnt = 0
    f(0,N,K,0)
    print(f'#{tc} {cnt}')
```

> Brute Force, 완전탐색
>
> 실행시간 : 4215ms 

```python
def f(N, K):
    cnt = 0
    for i in range(1<<N):
        total = 0
        for j in range(N):
            if i & (1<<j):
                total += arr[j]
        if total == K:
            cnt += 1
    return cnt

T = int(input())
for tc in range(1,T+1):
    N, K = map(int, input().split())
    arr =list(map(int, input().split()))

    ans = f(N,K)
    
    print(f'#{tc} {ans}')
```

## 2814. 최장 경로

```python

```

## 2805. 농작물 수확하기

```python
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    n = (N-1)//2
    arr = [list(map(int,input())) for _ in range(N)]
    lst = []
    for i in range(n+1):
        lst.append(i)
    for i in range(n):
        lst.append(n-i-1)

    total = 0
    for i in range(N):
        k = lst[i]
        for j in range(n-k, n+k+1):
            total += arr[i][j]
            
    print(f'#{tc} {total}')
```

## 2806. N-Queen

```python
def f(i,N):
    di = [0,0,1,-1,1,1,-1,-1]
    dj = [1,-1,0,0,1,-1,1,-1]
    global cnt
    if i == N:
        cnt += 1
    else:
        for j in range(N):
            if arr[i][j] == 0:
                # 행,열,대각선 다 i+1 로바꾸고
                arr[i][j] = i+1
                for l in range(1,N):
                    for k in range(8):
                        ni, nj =i+di[k]*l, j+dj[k]*l
                        if 0 <= ni < N and 0 <= nj < N and arr[ni][nj] == 0:
                            arr[ni][nj] = i+1
                # 다음 행으로 이동
                f(i+1, N)
                # 함수 끝내고 나오면 이전 상태로 원상복구 시켜놔야 다음 시행에 영향을 안줌
                arr[i][j] = 0
                for l in range(1, N):
                    for k in range(8):
                        ni, nj = i + di[k] * l, j + dj[k] * l
                        if 0 <= ni < N and 0 <= nj < N and arr[ni][nj] == i+1:
                            arr[ni][nj] = 0
                            
        else: # 중간에 놓을 자리가 없으면 거기서 끝
            return

T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = [[0]*N for _ in range(N)]

    cnt = 0
    f(0,N)
    print(f'#{tc} {cnt}')
```

## 1873. 상호의 배틀필드

> 인덱스 접근 종합문제느낌 ㅋㅋ..

```python
def location(H, W): # 시작 전차 위치
    for i in range(H):
        for j in range(W):
            if arr[i][j] not in '.*#-':
                return i, j

def boom(H, W, di,dj):
    k = 1
    while 0 <= i+di*k < H and 0 <= j+dj*k < W: # 맵 안에 있으면
        if arr[i+di*k][j+dj*k] == '*': # 벽돌 벽이 있으면
            arr[i+di*k][j+dj*k] = '.' # 평지로
            return
        elif arr[i+di*k][j+dj*k] == '#': # 강철 벽이면 거기서 그만
            return
        k += 1

T = int(input())
for tc in range(1, T+1):
    H, W = map(int, input().split())
    arr = [list(input()) for _ in range(H)]
    N = int(input())
    modes = list(input())

    i, j = location(H,W) # 전차 좌표
    move = {'U':[-1,0,'^'],'D':[1,0,'v'],'L':[0,-1,'<'],'R':[0,1,'>']} # 이동방향과 모양
    shoot = {'^':[-1,0],'v':[1,0],'<':[0,-1],'>':[0,1]} # 포탄 날라가는 방향

    for mode in modes:
        if mode == 'S': # 포탄 발사면
            di, dj = shoot[arr[i][j]] # 포탄 날라가는 방향 저장
            boom(H, W, di, dj) # 포탄 매뉴얼대로

        else: # 이동하는 입력이면
            di, dj, face = move[mode]
            arr[i][j] = face # 전차 방향모양 갱신
            ni, nj = i+di, j+dj
            if 0 <= ni < H and 0 <= nj < W and arr[ni][nj] == '.': # 평지면
                arr[ni][nj] = arr[i][j] # 위치 이동
                arr[i][j] = '.' # 전에 있던 자리는 평지
                i, j = ni, nj # 위치 갱신

    print(f'#{tc}', end=' ')
    for ar in arr:
        print(''.join(ar))
```

